<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <!-- <link rel="stylesheet" href="../../ui/css/reset.css" /> -->

    <link rel="preconnect" href="https://fonts.googleapis.com" /> 

    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /> 
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet" />

</head>
<body>



<style>
html, *, *:before, *:after {
    box-sizing: border-box;
}
ol, ul {
    list-style: none;
}
img {
    max-width: 100%;
    height: auto;
}
/* para default -9
p {
    margin: 1em 0 1em 0;
}
body {
    padding: 6vmin;
}

/* div */
.entry {
    display: flex;
    flex-direction: column;
    padding: 0 0 50px;
    background: #ccffcc;
}


/* paragraph */
article.entry p {
    font: 300 25px/30px Source Serif Pro, serif;
    max-width: 500px;

    opacity: 1;
    transition: opacity .25s ease-in-out;
}
article.entry p::after {
    font-size: 22px;
    content: ' ___default';
    color: red;
}

article.entry p:hover {
    opacity: .5;
}

article.entry .h3 {
    color: red;
    font: 500 16px/30px 'DM Sans', sans-serif;
    text-transform: uppercase;
    display: block;
    width: 156px;
    margin-bottom: 36px;
    vertical-align: top;
}



@media (min-width: 768px) {
    article.entry {
    }
    article.entry p {
        font: 30px/36px serif;

    }
    article.entry p::after {
        content: ' ___768px';
    }
    article.entry .h3 {
        line-height: 1.8;
    }
}
@media (min-width: 992px) {
    article.entry {
        padding: 0 0 100px;
    }
    article.entry p {
        font: 35px/42px serif;
        max-width: 650px;
    }
    article.entry p::after {
        content: ' ___992px';
    }
}
@media (min-width:1200px) {
    article.entry {
    }
    article.entry p {
        font: 45px/54px serif;
        max-width: 800px;
    }
    article.entry p::after {
        content: ' ___1200px';
    }
}
@media (min-width:1900px) {
    article.entry {
    }
    /* paragraph */
    article.entry p {
        font: 50px/60px serif;
        /* font-size: 50px;
        line-height: 60px; */
        max-width: 1100px;
    }
    article.entry p::after {
        content: ' ___1900px';
    }
}



@media (min-width: 768px) {
    article.entry .h3 {
        line-height: 1.8
    }
}
@media (min-width: 992px) {
    article.entry .h3 {
        display: inline-block;
        width: 189px;
        margin-bottom: 0;
        margin-top: 5px
    }
}
@media (min-width: 1200px) {
    article.entry .h3 {
        font-size: 16px
    }
}






article.entry p strong {
    font-family: DM Sans, sans-serif;
    font-weight: 500
}
article.entry p:last-child {
}

</style>


<main>






<article class="entry">
    <p>
        <span class="h3">dream / <time datetime="2021-11-14">2021-11-??</time></span>
        <span>Lorem ipsum dolor sit amet consectetur adipisicing elit. Incidunt, rerum fugiat accusantium adipisci autem iste dolorum ipsum quo debitis, nulla officia illo dolor ut natus sed delectus numquam voluptatem in.</span>
    </p>
</article>

<article class="entry">
    <p>
        <span class="h3">viszonyok / <time datetime="2021-11-14">2021-11-??</time></span>
        <span>én – én / én – te / én – ők viszonyok <a href="https://youtu.be/zZCAM8WHxVo?t=776">https://youtu.be/zZCAM8WHxVo?t=776</a></span>
    </p>
</article>

<article class="entry">
  <p>
      <span class="h3">viszonyok / <time datetime="2021-11-14">2021-11-??</time></span>
      <span>

        1. név: sziddhárta / aki a célját beteljesíti
        sziddha képesség 
        artha forrás elérés

        vagy a karma vagy a dharma kerekenek forgatoja lesz
        vagy vilaguralkodo vagy a belso vilag ura

        3 palotaban elt

        csakravartin / vilaguralkodo


        2. név: gotama remete
        nirotha -- elzárják az érzékszervi kapukat

        satori = pillanat alatti felismerés

        középút felismerése

        ha valaki felismeri a kozeputat teljesen egyedul marad



        3. név: buddha

        4 fázis megvilágosodás


        nirmanakaya
        látszattest



        buddha tanításai

        A négy nemes igazság

                    1. 2. = ez a kettô a karma igazsága / a következmények és az okok igazsága
                    3. 4. = dharma igazsága

        1. dukkha / a következmények igazsága / amit tapasztalunk az életben az következmény 
                  / a kimozdultság állapotában / legyen ez pozitív vagy negatív
                  a karmából a következmények igazsága

                  vidgya / marigpa = nemtudás okozza a dukkhát

                  Az 5 végtelen nézete
                  mahajana szutra / kicsiben a nagy nagyban a kicsi
                  határtalan / végtelen

                    Létezésünk 
                    1. végtele ntér
                    2. végtelen idô
                    3. végtelen létforma
                    4. végtelen képességek
                    5. végtelen tudat

                  SZEMLÉLET: a tudatunkat nyitni kell

        2. okok / feltárják hogy ezek miért okoznak szenvedést, miért kibillentek
                  az okok igazsága


                  hogyan tudunk kilépni a következményekbôl? mi tartja fent ezeket

                    4 világi nézet

                    1. materialistikus nézet
                    2. idealista nézet / vallásos / öröklét / ezotéria
                    3. determinisztikus nézet / vallásos / sors / horoszkóp pl.
                    4. szabad akarati nézet / spontán keletkezés / mi döntünk a sorsunk felett

                    ezek egyike sem felel meg a karma az ok-okozat törvényének

                    Téves fátyol
                    ezek miatt nem értjük meg a karmát


        ha  a dharma  igazságáról besdzlünk akkor ott nem ok és következmény hanem: 
        a rossz vagy a helytelen kioltása a jó gyakorlatának az igazsága

        3. nirodha / kioldódás igazsága
          ezek megváltoztathatóak / az okok szintjén
          a helytelen dolgok elhagyásáról szól / akuszala dhamma

          A 4 pecsét

          a karma állapotát értve eljutunk a darmáhaz

          1. pecsét: minden múlandó, ami keletkezett, összetett, elmúlik, szétesik
          2. pecsét: minden szennyezett dolog szenvedést eredményez
          fontos a lemondás a megtisztulás
          3. pecsét: nem létezik önvaló
          4. pecsét: a nirvána nem más mint a nyugalom boldogság, béke



        4, a helyes dolgok gyakorlása
            kuszala dhammák gyakorlása

            szemlélet:
            a középutas szemlélet:
            mely mentes az uorökléttanok és a megsemmisüléstanok szélsôségétôl

            sem nem
              pl; lélek:
              sem nem semmisül meg
              sem nem vándorol tovább


              kérdések

              1. ki viseli el a karma következényeit? ha nincs aki csalakedte, akkor ki viseli el
              2. van-e szabad akarat
              3. ki az aki emlékszik korábbi életekre / hogyan emlékezhetünk korábbi életekre
              4. ki születik újjá
            



        AZ ösvény

        8 lépcsôfoka van a középút ösvényének

        Felosztás                                           nyolcrétű ösvény tényezői        Megszerzett tényezők
        Bölcsesség (szanszkrit: pradzsnyá, páli: pannyá)    1. Helyes szemlélet / nézet     9. Legfelsőbb igaz tudás
                                                            2. Helyes szándék               10. Legfelsőbb igaz megszabadulás
        Erény (szanszkrit: síla, páli: szíla)               3. Helyes beszéd
                                                            4. Helyes cselekvés
                                                            5. Helyes életmód
        Elmélyedés (szanszkrit és páli: szamádhi)           6. Helyes erőfeszítés
                                                            7. Helyes éberség
                                                            8. Helyes elmélyedés




      </span>


      <span>

        Helyes elhatározás: 
        Helyes szándék:

        ezek mögött van értékrend

        mostani tapasztalat . kibillent
        múlandoság / korlát                   út              középen
        karma                               - darma         - nirvána éstékrendje






        
      </span>




  </p>
</article>


<div class="item">
    <img src="./img.jpg" class="js-image" alt="">
    <h2>Some title</h2>
    <p>Lorem ipsum.</p>
</div>




<br><br><br><br><br><br><br><br><br><br><br><br><br><br>d<br><br><br><br><br><br><br><br><br><br><br><br><div><br><br><br><br><br><br>
    <br><br><br><br><br><br><br><br><br>e<br><br><br><br><br><br><br><br>gdg
    <br><br><br><br><br><br><br><br>d<br><br><br><br><br><br><br><br><br>ddd
    <br><br><br><br><br><br><br><br><br><br><br>addEventListener
    <br><br><br><br><br><br><br><br><br>
  </main>
<script>


window.addEventListener('beforeunload', function (e) {
  // the absence of a returnValue property on the event will guarantee the browser unload happens
  // event.preventDefault();
  window.scrollTo(0, 0);
  delete e['returnValue'];
});


// window.onbeforeunload = function() {
//   window.scrollTo(0, 0);
// };



// scroll position and update function
let docScroll;
const getPageYScroll = () =>
  (docScroll = window.pageYOffset || document.documentElement.scrollTop);
window.addEventListener("scroll", getPageYScroll);


// SmoothScroll
class SmoothScroll {
  constructor() {
    this.shouldRender = false;
    // the <main> element
    this.DOM = { main: document.querySelector("main") };
    // the scrollable element
    // we translate this element when scrolling (y-axis)
    this.DOM.scrollable = this.DOM.main.querySelector("div[data-scroll]");
    // the items on the page
    this.items = [];

    this.createItems();
    this.listenMouse()

    // here we define which property will change as we scroll the page
    // in this case we will be translating on the y-axis
    // we interpolate between the previous and current value to achieve the smooth scrolling effect
    this.renderedStyles = {
      translationY: {
        // interpolated value
        previous: 0,
        // current value
        current: 0,
        // amount to interpolate
        ease: 0.1,
        // current value setter
        // in this case the value of the translation will be the same like the document scroll
        setValue: () => docScroll
      }
    };
    // set the body's height
    this.setSize();
    // set the initial values
    this.update();
    // the <main> element's style needs to be modified
    this.style();
    // init/bind events
    this.initEvents();
    // start the render loop
    requestAnimationFrame(() => this.render());
  }

  listenMouse(){
    document.addEventListener('mousemove',()=>{
      this.shouldRender = true;
    })
  }


  update() {
    // sets the initial value (no interpolation) - translate the scroll value
    for (const key in this.renderedStyles) {
      this.renderedStyles[key].current = this.renderedStyles[
        key
      ].previous = this.renderedStyles[key].setValue();
    }
    // translate the scrollable element
    this.setPosition();
    this.shouldRender = true;
  }
  setPosition() {
    // translates the scrollable element
    if (
      Math.round(this.renderedStyles.translationY.previous) !==
        Math.round(this.renderedStyles.translationY.current) ||
      this.renderedStyles.translationY.previous < 10
    ) {
      this.shouldRender = true;
      this.DOM.scrollable.style.transform = `translate3d(0,${-1 *
        this.renderedStyles.translationY.previous}px,0)`;
      // console.log(this.items);
      for (const item of this.items) {
        // if the item is inside the viewport call it's render function
        // this will update the item's inner image translation, based on the document scroll value and the item's position on the viewport
        if (item.isVisible || item.isBeingAnimatedNow) {
          item.render(this.renderedStyles.translationY.previous);
        }
      }
    }
    ;
    if(scene.targetSpeed>0.01) this.shouldRender = true;

    if (this.shouldRender) {
      this.shouldRender = false;
      scene.render();
    }

  }
  setSize() {
    // set the heigh of the body in order to keep the scrollbar on the page
    // console.log(this.DOM.scrollable.scrollHeight, 'HEIGHT');
    body.style.height = `${this.DOM.scrollable.scrollHeight}px`;
  }

  createItems() {
    IMAGES.forEach(image => {
      if (image.img.classList.contains("js-image")) {
        this.items.push(new Item(image, this));
      }
    });
  }

  style() {
    // the <main> needs to "stick" to the screen and not scroll
    // for that we set it to position fixed and overflow hidden
    this.DOM.main.style.position = "fixed";
    this.DOM.main.style.width = this.DOM.main.style.height = "100%";
    this.DOM.main.style.top = this.DOM.main.style.left = 0;
    this.DOM.main.style.overflow = "hidden";
  }
  initEvents() {
    // on resize reset the body's height
    window.addEventListener("resize", () => this.setSize());
  }
  render() {
    // update the current and interpolated values
    for (const key in this.renderedStyles) {
      this.renderedStyles[key].current = this.renderedStyles[key].setValue();
      this.renderedStyles[key].previous = MathUtils.lerp(
        this.renderedStyles[key].previous,
        this.renderedStyles[key].current,
        this.renderedStyles[key].ease
      );
    }
    // and translate the scrollable element
    this.setPosition();

    // loop..
    requestAnimationFrame(() => this.render());
  }
}



  // Get the scroll position
  getPageYScroll();

  // Initialize the Smooth Scrolling
  new SmoothScroll();




</script>

</body>
</html>